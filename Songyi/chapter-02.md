# 02장: 리액트 핵심 요소 깊게 살펴보기


## 2.1 JSX란?

JSX는 JavaScript를 확장한 문법으로 XML과 매우 유사항 내장형 구문이다.
JSX는 반드시 트랜스파일러를 거쳐야 하며, 이를 통해 JSX는 JavaScript로 변환된다.

```jsx
const element = <h1>Hello, world!</h1>;
```

### JSXElement
JSX를 구성하는 가장 기본 요소, HTML의 element 역할을 한다.

### JSXElementName
JSXElement의 요소 이름으로 쓸 수 있는 것을 의미한다.

### JSXAttributes
JSXElement에 속성을 부여할 수 있다.

### JSXChildren
JSXElement의 자식 값을 나타낸다.

### JSXStrings
JSXElement의 문자열 값을 나타낸다.


## 2.2 가상 DOM과 리액트 파이버

리액트는 가상 DOM을 사용하여 브라우저에 실제로 렌더링되기 전에 렌더링을 미리 수행한다. 이를 통해 렌더링 성능을 향상시킬 수 있다.

### 브라우저 랜더링 과정

1. 브라우저가 사용자가 요청한 주소를 방문해 HTML 파일을 다운로드한다.
2. 브라우저의 렌더링 엔진은 HTML을 파싱(해석)해 DOM 노드로 구성된 트리(DOM)를 만든다.
3. 2번 과정에서 CSS 파일을 만나면 해당 CSS 파일도 다운로드한다.
4. 브라우저의 렌더링 엔진은 이 CSS도 파싱해 CSS 노드로 구성된 트리(CSSOM)을 만든다.
5. 브라우저는 2번에서 만든 DOM 노드를 순회하는데, 모든 노드를 순회하는 것이 아닌, 사용자 눈에 보이는 노드만 순회한다.
6. 5번에 제외된, 눈에 보이는 노드를 대상으로 해당 노드에 대한 CSSOM 정보를 찾고 CSS 정보를 노드에 적용한다. 
  - 레이아웃(layout) : 각 노드가 브라우저 화면의 어느 좌표에 정확히 나타나야 하는지 계산하는 과정.
  - 페인팅(painting) : 레이아웃 단계를 거친 노드에 색과 같은 실제 유효한 모습을 그리는 과정.

### 리액트 파이버

리액트 파이버는 리액트의 코어 알고리즘을 새롭게 구현한 것으로, 리액트 16버전부터 적용되었다. 리액트 파이버는 리액트의 내부 동작 방식을 변경하고, 렌더링 성능을 향상시키는 데 사용된다.

리액트 파이버는 렌더링을 위해 가상 DOM을 사용한다. 가상 DOM은 실제 DOM의 복사본으로, 리액트는 가상 DOM을 사용해 실제 DOM에 렌더링하기 전에 미리 렌더링을 수행한다.

리액트 파이버에서 수행하는 작업은 다음과 같다. 이 모든 작업은 비동기로 일어난다.
- 작업을 작은 단위로 분할하고 쪼갠 다음, 우선순위를 매긴다.
- 이러한 작업을 일시 중지하고, 나중에 다시 시작할 수 있다.
- 이전에 했던 작업을 다시 재사용하거나 필요하지 않은 경우에는 폐기할 수 있다.

### 리엑트 파이버의 작업 순서

```JSX
<A1>
  <B1>안녕하세요</B1>
  <B2>
    <C1>
      <D1 />
      <D2 />
    </C1>
  </B2>
  <B3 />
</A1>
```

1. A1의 beginWork()가 수행된다.
2. A1은 자식이 있으므로 B1로 이동해 beginWork()를 수행한다.
3. B1은 자식이 없으므로 completeWork()가 수행됐다. 자식은 없으므로 형제(sibling)인 B2로 넘어간다.
4. B2의 beginWork()가 수행된다. 자식이 있으므로 C1로 이동한다.
5. C1의 beginWork()가 수행된다. 자식이 있으므로 D1로 이동한다.
6. D1의 beginWork()가 수행된다.
7. D1의 자식이 없으므로 형제(sibling)인 D2로 넘어간다. 
8. D2의 beginWork()가 수행되고, 자식이 없으므로 completeWork()가 수행됐다. 
9. D2는 자식도 형제도 없으므로, 위로 이동해 C1, B2 순으로 completeWork()를 호출한다. 
10. B2는 형제(sibling)인 B3으로 이동해 beginWork()를 수행한다. 
11. B3의 completeWork()가 수행되면 반환해 상위로 타고 올라간다. 
12. A1의 completeWork()가 수행된다. 
13. 루트 노드가 완성되면 commitWork()가 수행되고 이 중 변경 사항을 비교해 업데이트가 필요한 변경사항이 DOM에 반영된다.

파이버는 리액트 아키텍쳐 내부에서 비동기로 이뤄진다.
메모리상에서 먼저 수행하여 최종적인 결과물만 실제 브라우저 DOM에 적용한다.


## 2.3 클래스형 컴포넌트와 함수형 컴포넌트

### 클래스형 컴포넌트

클래스형 컴포넌트는 클래스를 선언하고 extends로 만들고 싶은 컴포넌트를 extends 해야한다.

extends 구문에 넣을 수 있는 클래스
- React.Component
- React.PureComponent

클래스형 컴포넌트 코드
- constructor: 컴포넌트가 생성될 때 호출되는 함수
- props: 함수에 인수를 넣는 것과 비슷하게 컴포넌트에 특정 속성을 전달하는 용도.
- state: 클래스 컴포넌트 내부에서 관리하는 값
- method: 렌더링 함수 내부에서 사용되는 함수

클래스 컴포넌트의 생명주기 메서드(lifecycle)
- 마운트(mount) : 컴포넌트가 마운팅(생성)되는 시점
- 업데이트(update) : 이미 생성된 컴포넌트의 내용이 변경(업데이트)되는 시점
- 언마운트(unmount) : 컴포넌트가 더 이상 존재하지 않는 시점

클래스 컴포넌트의 한계
- 데이터 흐름을 추적하기 어렵다.
- 애플리케이션 내부 로직의 재사용이 어렵다.
- 기능이 많아질수록 컴포넌트의 크기가 커진다.
- 클래스는 함수에 비해 상대적으로 어렵다.
- 코드 크기를 최적화하기 어렵다.
- 핫 리로딩을 하는 데 상대적으로 불리하다.

### 함수형 컴포넌트

함수형 컴포넌트는 함수를 선언하고, 함수 내부에서 JSX를 반환한다.

함수형 컴포넌트는 클래스 컴포넌트보다 확연히 코드가 간결하다.

render 내부에서 this 바인딩을 조심할 필요가 없으며, state는 객체가 아닌 각각의 원시값으로 관리되어 훨씬 사용하기가 편하다.

렌더링하는 코드인 return 또한 굳이 this를 사용하지 않아도, props와 state를 사용할 수 있다.


## 2.4 렌더링은 어떻게 일어나는가?

리액트에서의 렌더링이란 리액트 애플리케이션 트리 안에 있는 모든 컴포넌트들이 현재 자신들이 가지고 있는 props와 state의 값을 기반으로 어떻게 UI를 구성하고 이를 바탕으로 어떤 DOM 결과를 브라우저에 제공할 것인지 계산하는 일련의 과정을 의미한다.

리액트 렌더링이 발생하는 시나리오
- 최초 렌더링 : 사용자가 처음 애플리케이션에 진입하면 당연히 렌더링해야 할 결과물이 필요하다. 리액트는 브라우저에게 정보를 제공하기 위해 최초 렌더링을 수행한다.
- 리렌더링 : 최초 렌더링 이후 발생하는 모든 렌더링을 의미한다.
  - 클래스 컴포넌트의 setState()가 실행되는 경우
  - 클래스 컴포넌트의 forceUpdate()가 실행되는 경우
  - 함수 컴포넌트의 useState()의 두번째 배열 요소인 setter가 실행되는 경우
  - 함수 컴포넌트의 useState()의 두번째 배열 요소인 dispatch가 실행되는 경우
  - 컴포넌트의 key props가 변경되는 경우

렌더링 프로세스가 시작되면 리액트는 컴포넌트의 루트에서부터 차근차근 아래쪽으로 내려가면서 업데이트가 필요하다고 지정돼 있는 모든 컴포넌트를 찾는다. 각 컴포넌트의 렌더링 결과물을 수집한 다음, 리액트의 새로운 트리인 가상 DOM과 비교해 실제 DOM에 반영하기 위한 모든 변경 사항을 차례차례 수집한다.

렌더 단계 - 컴포넌트를 렌더링하고 변경 사항을 계산하는 모든 작업을 수행하는 단계.

커밋 단계 - 렌더 단계의 변경 사항을 실제 DOM에 적용해 사용자에게 보여주는 단계.

리액트의 렌더링이 일어난다고 해서 무조건 DOM 업데이트가 일어나는 것은 아니다.


## 2.5 컴포넌트와 함수의 무거운 연산을 기억해 두는 메모이제이션

메모이제이션: 값비싼 함수 호출의 결과를 캐싱하고 동일한 입력이 다시 발생할 때 불필요하게 다시 계산하는 대신 캐싱된 결과를 반환하는 기술을 의미한다.

리액트의 API중 useMemo, useCallback 훅과 고차 컴포넌트인 memo는 리액트에서 발생하는 렌더링을 최소한으로 줄이기 위해서 제공된다.

항상 메모이제이션은 신중하게 접근해야 하며 섣부른 최적화는 항상 경계해야 한다.
