# 🐻 02. 리액트 핵심요소 깊게 살펴보기

> - 책 내용 정리
> - 새로 알게된 내용들
> - 이해가 안되거나 궁금했던 점
> - 실무에서 적용 부분, 나의 생각

## 책 내용 정리

- 2.1 JSX란?
- 2.2 가상 DOM과 리액트 파이버
- 2.3 클래스 컴포넌트와 함수 컴포넌트
- 2.4 렌더링은 어떻게 일어나는가?
- 2.5 컴포넌트와 함수의 무거운 연산을 기억해두는 메모이제이션

---

### 2.1 JSX

JSX는 XML과 유사한 내장형 구문이며, 리액트에 종속적이지 않은 독자적인 문법이다. ECMAScript 표준의 일부는 아니라서,JSX 트랜스타일러를 거쳐야 자바스크립트 런타임이 이해할 수 있는 의미있는 자바스크립트 코드로 변환된다.

JSX의 설계목적: 다양한 속성을 가진 트리 구조를 토큰화해 ECMAScript로 변환.

> -> JSX 내부에 XML 스타일의 트리 구조로 표현하고 싶은 다양한 것들을 작성<br>
> -> 트랜스파일 과정을 거쳐 자바스크립트가 이해할 수 있는 코드로 변경.

JSX의 4가지 컴포넌트

- JSXElement
  - < JSXOpeningElement>~~~
  - ~~</ JSXClosingElement>
  - < JSXSelfClosingElement/>
  - <></> (JSXFragment)
  - 이름규칙
    - 특수문자 안됨($,\_ 이외)
    - : 한개까지 사용가능(< foo:bar></foo:bar>)
    - . 가능 (<foo.bar>)
- JSXAttributes : JSXElement에 부여할 수 있는 속성
  - <Component ...JSXSpreadAttributes />
  - <Component JSXAttributeName:JSXAttributeValue />
      - JSXAttributeValue로 올 수 있는 값: '', "", {}, <div>component</div>
- JSXChildren
- JSXStrings

JSX가 JavaScript로 변환되는 과정
`@babel/plugin-transform-react-jsx` 플러그인에서 JSX 구문을 자바스크립트가 이해할 수 있는 형태로 변환

### 2.2 가상 DOM과 리액트 파이버

가상 DOM이 무엇인지, 실제 DOM에 비해 어떤 이점이 있는지, 주의할 점

가상 DOM: 리액트가 관리하는 가상의 DOM
실제 브라우저의 DOM이 아님, 웹페이지가 표시해야할 DOM을 메모리에서 계산해 저장하고, 실제 변경에 대한 준비가 완료됐을 때, 실제 브라우저의 DOM에 반영한다.

리액트 파이버 : 리액트에서 관리하는 자바스크립트 객체(?). 파이버는 파이버 재조정자(fiber reconciler)가 관리.

파이버 재조정자 : 가상DOM과 실제DOM을 비교해 변경사항을 수집하며,이 둘 사이에 차이가 있으면 변경에 관련된 정보를 갖고있는 파이버를 기준으로 렌더링 요청.

재조정(reconciliation): 가상 DOM과 실제 DOM을 비교하는 작업(알고리즘)

파이버의 역할

- 작업을 작은 단위로 분할하고 쪼갠 다음, 우선순위를 매긴다.
- 이러한 작업을 일시 중지하고 나중에 다시 시작할 수 있다.
- 이전에 했던 작업을 다시 재사용하거나 필요하지 않은 경우에는 폐기할 수 있다.

: 이 모든 과정은 비동기로 일어남.
과거에는 스택 조정자로 동기적으로 일어나서 다른 작업을 못했지만,,, 지금은 파이버 덕분에 비동기적으로 사용자 입력과 별개로 작업 가능

파이버 - 하나의 작업 단위, 마무리할땐 finishedWork()로 마무리. 하나의 element에 하나가 생성되는 1:1의 관계를 갖고있음.

- Render Phase : 사용자에게 노출되지 않는 모든 비동기 작업을 수행. 파이버의 작업, 우선순위 지정, 중지 등의 작업이 일어난다.
- Commit Phase : DOM에 실제 변경사항을 반영하기 위한 작업. commitWork()가 실행, 동기식으로 발생하고 중단 불가능.

파이버 객체에서는 UI를 문자열, 숫자, 배열과 같은 '값'으로 관리.

파이버 트리.

- 더블 버퍼링 기술 적용
- 현재 모습을 담은 파이버트리와, 작업중인 상태를 나타내는 WorkInProgress 트리가 존재. 파이버 작업이 끝나면 포인터만 변경해 WIP 트리를 현재 트리로 바꿔버린다.
- Commit Phase에서 씀(=동기식으로 발생)

### 2.3 클래스 컴포넌트와 함수 컴포넌트

초기에 함수 컴포넌트는 무상태 함수 컴포넌트(stateless functional component)로 정적 렌더링이 목적이었음.

- 클래스 컴포넌트의 생명주기가 함수 컴포넌트에는 존재하지 않음. 생명주기 메서드는 React.Component에서 오는것이기 떄문
  (함수 컴포넌트는 props를 받아 단순히 리액트 요소만 반환하는 함수인 반면, 클래스 컴포넌트는 render 메서드가 있는 React.Component를 상속받아 구현하는 클래스 이기 때문)
- useEffect 훅을 통해 생명주기 메서드를 비슷하게 구현할 수 있지만..? 다름.( 함수 컴포넌트는 클릭 시점의 props값(stste)을 기준으로 메세지 발생, 클래스 컴포넌트는 최종 props값을 적용)

### 2.4 렌더링은 어떻게 일어나는가?

리액트의 렌더링:

> - 브라우저가 렌더링에 필요한 DOM트리를 만드는 과정.
> - 리액트 안의 모든 컴포넌트들이 갖고있는 props와 state값을 기반으로 어떻게 UI를 구성하고 이를 바탕으로 어떤 DOM 결과를 브라우저에 제공할 것인지 계산하는 일련의 과정

렌더링이 발생할 때 : 최초 렌더링, 리렌더링 시.

리렌더링 시나리오 :

- 클래스 컴포넌트의 setState 실행
- 클래스 컴포넌트의 forceUpdate tlfgod
- 함수 컴포넌트의 setter(setState..)실행
- 함수 컴포넌트의 useReducer()의 dispatch 실행
- 컴포넌트의 key props 변경 시
  - current트리와 WIP트리사이에서 같은 컴포넌트인지를 구별하는 값이 key값임.
- prop 변경 시
- 부모 컴포넌트가 리렌더링 될 시

이 외에는 리렌더링 발생시키지 않음!

- MobX나 Redux 같은 라이브러리는 리액트의 리렌더링으로 이어지지는 않음.
  - mobx-react, react-redux 같은 패키지를 설치해서, 위에서 언급된 방법들 중 하나를 사용해 리렌더링을 발생시킴
- recoil같은 경우엔 useState를 통해 리렌더링을 발생(별도의 패키지 없음)

렌더링 프로세스

업데이트가 필요하다고 지정돼있는 모든 컴포넌트를 찾음
업데이트 필요 ? ->

- 클래스 컴포넌트인 경우 render() 함수 실행
- 함수 컴포넌트인 경우엔 FunctionComponent() 자체를 호출
  결과물을 저장

결과물은 JSX 문법으로 구성되어 있음. -> 자바스크립트로 컴파일 -> 일반 자바스크립트 객체를 반환

```jsx
function Hello() {
  return (
    <TestComponent a={27} b="kyilee">
      안녕?
    </TestComponent>
  );
}
```

자바스크립트로 컴파일 - React.createElement()를 호출해서 변환

```js
function Hello() {
  return React.createElement(TestComponent, { a: 35, b: "kyilee" }, "안녕?");
}
```

자바스크립트 객체로 변환

```js
{type: TestComponent, props: {a: 27, b: 'kyilee', children: '안녕?'}}
```

- Render Phase : 컴포넌트를 렌더링하고 변경사항을 계산하는 모든 작업. return 한 결과와 이전 가상 DOM을 비교하는 과정.
- Commit Phase : DOM에 실제 변경사항을 반영하기 위한 작업.

커밋단계까지 끝나면 비로소 브라우저의 렌더링 발생.

모든 DOM 노드 및 인스턴스를 가리키도록 리액트 내부의 참조를 업데이트 한다.

- 생명주기 개념이 있는 클래스 컴포넌트에서는 componentDidMount, componentDidUpdate 메서드를 호출,
- 함수 컴포넌트에서는 useLayoutEffect 훅을 호출

리액트의 렌더링에서, render phase의 결과로 아무 변경사항이 감지되지 않았다면, commit phase는 생략될 수 있음.

-> 이 렌더링 과정은 항상 동기식으로 작동했다. 이후 react 18 에서 동시성 렌더링이 도입되면서 render phase단계가 비동기적으로 작동하기 시작했다.

### 2.5 메모이제이션

언제, 어떤상황에 추가해야하는가?

- 리액트를 깊이 이해하고 싶고, 시간을 투자할 여유가 있는사람

  > : 성능상 이점을 누릴 순간이 언젠지 살펴보는 식으로 메모이제이션 적용

- 현업에서 리액트를 사용하고 있고, 성능에 대해 깊이 연구해 볼 시간적 여유가 없는 상황
  > : 의심스러운곳에 다 적용해보기, props 에 대한 얕은 비교를 수행하는 것보다 리액트 컴포넌트의 결과물을 다시 계산하고 실제 DOM까지 비교하는 작업이 더 무겁고 비쌈. useMemo나 useCallback 또한 마찬가지로 props로 넘어갔을 때 참조 투명성을 유지하기 위해서 사용하는 것이 좋음

### 새로 알게된 내용들

- JSX가 JS로 변환되는 과정,
- 생명주기는 함수형 컴포넌트에서는 적용 안되는 점이었다는것..! 그럼에도 useEffect를 설명할 때 왜 많은곳에서 생명주기를 언급했는지 알 수 있었음

### 이해가 안된+궁금한 점

- 그래서 render phase는 비동기인가, 동기인가?
  원래 동기적으로 작동했지만 React18에 들어가면서 비동기로 작동한다는 뜻인가/?
- 렌더링 큐와 자바스크립트 v8엔진의 실행 컨텍스트와의 관계???

### 실무에서 적용한 부분, 나의 생각
